// =============
// This file is autogenerated by obj_gen
// DO NOT EDIT
// =============

use super::*;

macro_rules! obj_fmt {
    ($f:ident, $self:ident, $($key:ident),*) => {
        $(if let Some(v) = $self . $key () { $f .field(stringify!($key), & v); })*
    };
}

/// Spa:Pod:Object:Param:PropInfo
pub struct PropInfo<'a>(pub PodObjectDeserializer<'a>);
impl<'a> PropInfo<'a> {
    fn get_raw(&self, id: u32) -> Option<PodDeserializer> {
        self.0.clone().find(|v| v.key == id).map(|v| v.value)
    }
    fn get(&self, key: SpaPropInfo) -> Option<PodDeserializer> {
        self.get_raw(key.to_u32().unwrap())
    }
    /// Spa:Pod:Object:Param:PropInfo:id
    fn id(&self) -> Option<SpaEnum<SpaProp>> {
        self.get(SpaPropInfo::Id)?
            .as_id()
            .map(SpaEnum::from_raw)
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:PropInfo:id"))
            .ok()
    }
    /// Spa:Pod:Object:Param:PropInfo:name
    fn name(&self) -> Option<&BStr> {
        self.get(SpaPropInfo::Name)?
            .as_str()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:PropInfo:name"))
            .ok()
    }
    /** Spa:Pod:Object:Param:PropInfo:type
        parent: Pod
    */
    fn ty(&self) -> Option<PodDeserializer> {
        self.get(SpaPropInfo::Type)
    }
    /// Spa:Pod:Object:Param:PropInfo:labels
    fn labels(&self) -> Option<PodStructDeserializer> {
        self.get(SpaPropInfo::Labels)?
            .as_struct()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:PropInfo:labels"))
            .ok()
    }
    /// Spa:Pod:Object:Param:PropInfo:container
    fn container(&self) -> Option<u32> {
        self.get(SpaPropInfo::Container)?
            .as_id()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:PropInfo:container"))
            .ok()
    }
    /// Spa:Pod:Object:Param:PropInfo:params
    fn params(&self) -> Option<bool> {
        self.get(SpaPropInfo::Params)?
            .as_bool()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:PropInfo:params"))
            .ok()
    }
    /// Spa:Pod:Object:Param:PropInfo:description
    fn description(&self) -> Option<&BStr> {
        self.get(SpaPropInfo::Description)?
            .as_str()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:PropInfo:description"))
            .ok()
    }
}
impl<'a> std::fmt::Debug for PropInfo<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut f = f.debug_struct("PropInfo");
        obj_fmt!(
            f,
            self,
            id,
            name,
            ty,
            labels,
            container,
            params,
            description
        );
        f.finish()
    }
}

/// Spa:Pod:Object:Param:Props
pub struct Props<'a>(pub PodObjectDeserializer<'a>);
impl<'a> Props<'a> {
    fn get_raw(&self, id: u32) -> Option<PodDeserializer> {
        self.0.clone().find(|v| v.key == id).map(|v| v.value)
    }
    fn get(&self, key: SpaProp) -> Option<PodDeserializer> {
        self.get_raw(key.to_u32().unwrap())
    }
    /// Spa:Pod:Object:Param:Props:device
    fn device(&self) -> Option<&BStr> {
        self.get(SpaProp::Device)?
            .as_str()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Props:device"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Props:deviceName
    fn device_name(&self) -> Option<&BStr> {
        self.get(SpaProp::DeviceName)?
            .as_str()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Props:deviceName"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Props:deviceFd
    fn device_fd(&self) -> Option<i64> {
        self.get(SpaProp::DeviceFd)?
            .as_fd()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Props:deviceFd"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Props:card
    fn card(&self) -> Option<&BStr> {
        self.get(SpaProp::Card)?
            .as_str()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Props:card"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Props:cardName
    fn card_name(&self) -> Option<&BStr> {
        self.get(SpaProp::CardName)?
            .as_str()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Props:cardName"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Props:minLatency
    fn min_latency(&self) -> Option<i32> {
        self.get(SpaProp::MinLatency)?
            .as_i32()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Props:minLatency"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Props:maxLatency
    fn max_latency(&self) -> Option<i32> {
        self.get(SpaProp::MaxLatency)?
            .as_i32()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Props:maxLatency"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Props:periods
    fn periods(&self) -> Option<i32> {
        self.get(SpaProp::Periods)?
            .as_i32()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Props:periods"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Props:periodSize
    fn period_size(&self) -> Option<i32> {
        self.get(SpaProp::PeriodSize)?
            .as_i32()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Props:periodSize"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Props:periodEvent
    fn period_event(&self) -> Option<bool> {
        self.get(SpaProp::PeriodEvent)?
            .as_bool()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Props:periodEvent"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Props:live
    fn live(&self) -> Option<bool> {
        self.get(SpaProp::Live)?
            .as_bool()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Props:live"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Props:rate
    fn rate(&self) -> Option<f64> {
        self.get(SpaProp::Rate)?
            .as_f64()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Props:rate"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Props:quality
    fn quality(&self) -> Option<i32> {
        self.get(SpaProp::Quality)?
            .as_i32()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Props:quality"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Props:bluetoothAudioCodec
    fn bluetooth_audio_codec(&self) -> Option<SpaEnum<SpaBluetoothAudioCodec>> {
        self.get(SpaProp::BluetoothAudioCodec)?
            .as_id()
            .map(SpaEnum::from_raw)
            .map_err(|err| {
                unreachable!(
                    "{}: {err}",
                    "Spa:Pod:Object:Param:Props:bluetoothAudioCodec"
                )
            })
            .ok()
    }
    /// Spa:Pod:Object:Param:Props:bluetoothOffloadActive
    fn bluetooth_offload_active(&self) -> Option<bool> {
        self.get(SpaProp::BluetoothOffloadActive)?
            .as_bool()
            .map_err(|err| {
                unreachable!(
                    "{}: {err}",
                    "Spa:Pod:Object:Param:Props:bluetoothOffloadActive"
                )
            })
            .ok()
    }
    /// Spa:Pod:Object:Param:Props:waveType
    fn wave_type(&self) -> Option<u32> {
        self.get(SpaProp::WaveType)?
            .as_id()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Props:waveType"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Props:frequency
    fn frequency(&self) -> Option<i32> {
        self.get(SpaProp::Frequency)?
            .as_i32()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Props:frequency"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Props:volume
    fn volume(&self) -> Option<f32> {
        self.get(SpaProp::Volume)?
            .as_f32()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Props:volume"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Props:mute
    fn mute(&self) -> Option<bool> {
        self.get(SpaProp::Mute)?
            .as_bool()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Props:mute"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Props:patternType
    fn pattern_type(&self) -> Option<u32> {
        self.get(SpaProp::PatternType)?
            .as_id()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Props:patternType"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Props:ditherType
    fn dither_type(&self) -> Option<u32> {
        self.get(SpaProp::DitherType)?
            .as_id()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Props:ditherType"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Props:truncate
    fn truncate(&self) -> Option<bool> {
        self.get(SpaProp::Truncate)?
            .as_bool()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Props:truncate"))
            .ok()
    }
    /** Spa:Pod:Object:Param:Props:channelVolumes
        parent: Array<Spa:floatArray>
    */
    fn channel_volumes(&self) -> Option<PodArrayDeserializer> {
        self.get(SpaProp::ChannelVolumes)?
            .as_array()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Props:channelVolumes"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Props:volumeBase
    fn volume_base(&self) -> Option<f32> {
        self.get(SpaProp::VolumeBase)?
            .as_f32()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Props:volumeBase"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Props:volumeStep
    fn volume_step(&self) -> Option<f32> {
        self.get(SpaProp::VolumeStep)?
            .as_f32()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Props:volumeStep"))
            .ok()
    }
    /** Spa:Pod:Object:Param:Props:channelMap
        parent: Array<Spa:channelMap>
    */
    fn channel_map(&self) -> Option<PodArrayDeserializer> {
        self.get(SpaProp::ChannelMap)?
            .as_array()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Props:channelMap"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Props:monitorMute
    fn monitor_mute(&self) -> Option<bool> {
        self.get(SpaProp::MonitorMute)?
            .as_bool()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Props:monitorMute"))
            .ok()
    }
    /** Spa:Pod:Object:Param:Props:monitorVolumes
        parent: Array<Spa:floatArray>
    */
    fn monitor_volumes(&self) -> Option<PodArrayDeserializer> {
        self.get(SpaProp::MonitorVolumes)?
            .as_array()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Props:monitorVolumes"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Props:latencyOffsetNsec
    fn latency_offset_nsec(&self) -> Option<i64> {
        self.get(SpaProp::LatencyOffsetNsec)?
            .as_i64()
            .map_err(|err| {
                unreachable!("{}: {err}", "Spa:Pod:Object:Param:Props:latencyOffsetNsec")
            })
            .ok()
    }
    /// Spa:Pod:Object:Param:Props:softMute
    fn soft_mute(&self) -> Option<bool> {
        self.get(SpaProp::SoftMute)?
            .as_bool()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Props:softMute"))
            .ok()
    }
    /** Spa:Pod:Object:Param:Props:softVolumes
        parent: Array<Spa:floatArray>
    */
    fn soft_volumes(&self) -> Option<PodArrayDeserializer> {
        self.get(SpaProp::SoftVolumes)?
            .as_array()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Props:softVolumes"))
            .ok()
    }
    /** Spa:Pod:Object:Param:Props:iec958Codecs
        parent: Array<Spa:iec958Codec>
    */
    fn iec958_codecs(&self) -> Option<PodArrayDeserializer> {
        self.get(SpaProp::Iec958Codecs)?
            .as_array()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Props:iec958Codecs"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Props:volumeRampSamples
    fn volume_ramp_samples(&self) -> Option<i32> {
        self.get(SpaProp::VolumeRampSamples)?
            .as_i32()
            .map_err(|err| {
                unreachable!("{}: {err}", "Spa:Pod:Object:Param:Props:volumeRampSamples")
            })
            .ok()
    }
    /// Spa:Pod:Object:Param:Props:volumeRampStepSamples
    fn volume_ramp_step_samples(&self) -> Option<i32> {
        self.get(SpaProp::VolumeRampStepSamples)?
            .as_i32()
            .map_err(|err| {
                unreachable!(
                    "{}: {err}",
                    "Spa:Pod:Object:Param:Props:volumeRampStepSamples"
                )
            })
            .ok()
    }
    /// Spa:Pod:Object:Param:Props:volumeRampTime
    fn volume_ramp_time(&self) -> Option<i32> {
        self.get(SpaProp::VolumeRampTime)?
            .as_i32()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Props:volumeRampTime"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Props:volumeRampStepTime
    fn volume_ramp_step_time(&self) -> Option<i32> {
        self.get(SpaProp::VolumeRampStepTime)?
            .as_i32()
            .map_err(|err| {
                unreachable!("{}: {err}", "Spa:Pod:Object:Param:Props:volumeRampStepTime")
            })
            .ok()
    }
    /// Spa:Pod:Object:Param:Props:volumeRampScale
    fn volume_ramp_scale(&self) -> Option<u32> {
        self.get(SpaProp::VolumeRampScale)?
            .as_id()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Props:volumeRampScale"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Props:brightness
    fn brightness(&self) -> Option<f32> {
        self.get(SpaProp::Brightness)?
            .as_f32()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Props:brightness"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Props:contrast
    fn contrast(&self) -> Option<f32> {
        self.get(SpaProp::Contrast)?
            .as_f32()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Props:contrast"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Props:saturation
    fn saturation(&self) -> Option<f32> {
        self.get(SpaProp::Saturation)?
            .as_f32()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Props:saturation"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Props:hue
    fn hue(&self) -> Option<i32> {
        self.get(SpaProp::Hue)?
            .as_i32()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Props:hue"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Props:gamma
    fn gamma(&self) -> Option<i32> {
        self.get(SpaProp::Gamma)?
            .as_i32()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Props:gamma"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Props:exposure
    fn exposure(&self) -> Option<i32> {
        self.get(SpaProp::Exposure)?
            .as_i32()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Props:exposure"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Props:gain
    fn gain(&self) -> Option<f32> {
        self.get(SpaProp::Gain)?
            .as_f32()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Props:gain"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Props:sharpness
    fn sharpness(&self) -> Option<f32> {
        self.get(SpaProp::Sharpness)?
            .as_f32()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Props:sharpness"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Props:params
    fn params(&self) -> Option<PodStructDeserializer> {
        self.get(SpaProp::Params)?
            .as_struct()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Props:params"))
            .ok()
    }
}
impl<'a> std::fmt::Debug for Props<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut f = f.debug_struct("Props");
        obj_fmt!(
            f,
            self,
            device,
            device_name,
            device_fd,
            card,
            card_name,
            min_latency,
            max_latency,
            periods,
            period_size,
            period_event,
            live,
            rate,
            quality,
            bluetooth_audio_codec,
            bluetooth_offload_active,
            wave_type,
            frequency,
            volume,
            mute,
            pattern_type,
            dither_type,
            truncate,
            channel_volumes,
            volume_base,
            volume_step,
            channel_map,
            monitor_mute,
            monitor_volumes,
            latency_offset_nsec,
            soft_mute,
            soft_volumes,
            iec958_codecs,
            volume_ramp_samples,
            volume_ramp_step_samples,
            volume_ramp_time,
            volume_ramp_step_time,
            volume_ramp_scale,
            brightness,
            contrast,
            saturation,
            hue,
            gamma,
            exposure,
            gain,
            sharpness,
            params
        );
        f.finish()
    }
}

/// Spa:Pod:Object:Param:Format
pub struct Format<'a>(pub PodObjectDeserializer<'a>);
impl<'a> Format<'a> {
    fn get_raw(&self, id: u32) -> Option<PodDeserializer> {
        self.0.clone().find(|v| v.key == id).map(|v| v.value)
    }
    fn get(&self, key: SpaFormat) -> Option<PodDeserializer> {
        self.get_raw(key.to_u32().unwrap())
    }
    /** Spa:Pod:Object:Param:Format:mediaType
        parent: Pod
    */
    fn media_type(&self) -> Option<PodDeserializer> {
        self.get(SpaFormat::MediaType)
    }
    /** Spa:Pod:Object:Param:Format:mediaSubtype
        parent: Pod
    */
    fn media_subtype(&self) -> Option<PodDeserializer> {
        self.get(SpaFormat::MediaSubtype)
    }
    /** Spa:Pod:Object:Param:Format:Audio:format
        parent: Pod
    */
    fn audio_format(&self) -> Option<PodDeserializer> {
        self.get(SpaFormat::AudioFormat)
    }
    /** Spa:Pod:Object:Param:Format:Audio:flags
        enum: Spa:Flags:AudioFlags
        value-0: "Spa:Flags:AudioFlags:none"
        value-1: "Spa:Flags:AudioFlags:unpositioned"
    */
    fn audio_flags(&self) -> Option<u32> {
        self.get(SpaFormat::AudioFlags)?
            .as_id()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Format:Audio:flags"))
            .ok()
    }
    /** Spa:Pod:Object:Param:Format:Audio:rate
        parent: Pod
    */
    fn audio_rate(&self) -> Option<PodDeserializer> {
        self.get(SpaFormat::AudioRate)
    }
    /** Spa:Pod:Object:Param:Format:Audio:channels
        parent: Pod
    */
    fn audio_channels(&self) -> Option<PodDeserializer> {
        self.get(SpaFormat::AudioChannels)
    }
    /** Spa:Pod:Object:Param:Format:Audio:position
        parent: Pod
    */
    fn audio_position(&self) -> Option<PodDeserializer> {
        self.get(SpaFormat::AudioPosition)
    }
    /// Spa:Pod:Object:Param:Format:Audio:iec958Codec
    fn audio_iec958_codec(&self) -> Option<PodChoiceDeserializer> {
        self.get(SpaFormat::AudioIec958Codec)?
            .as_choice()
            .map_err(|err| {
                unreachable!("{}: {err}", "Spa:Pod:Object:Param:Format:Audio:iec958Codec")
            })
            .ok()
    }
    /// Spa:Pod:Object:Param:Format:Audio:bitorder
    fn audio_bitorder(&self) -> Option<SpaEnum<SpaParamBitorder>> {
        self.get(SpaFormat::AudioBitorder)?
            .as_id()
            .map(SpaEnum::from_raw)
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Format:Audio:bitorder"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Format:Audio:interleave
    fn audio_interleave(&self) -> Option<i32> {
        self.get(SpaFormat::AudioInterleave)?
            .as_i32()
            .map_err(|err| {
                unreachable!("{}: {err}", "Spa:Pod:Object:Param:Format:Audio:interleave")
            })
            .ok()
    }
    /// Spa:Pod:Object:Param:Format:Audio:bitrate
    fn audio_bitrate(&self) -> Option<i32> {
        self.get(SpaFormat::AudioBitrate)?
            .as_i32()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Format:Audio:bitrate"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Format:Audio:blockAlign
    fn audio_block_align(&self) -> Option<i32> {
        self.get(SpaFormat::AudioBlockAlign)?
            .as_i32()
            .map_err(|err| {
                unreachable!("{}: {err}", "Spa:Pod:Object:Param:Format:Audio:blockAlign")
            })
            .ok()
    }
    /// Spa:Pod:Object:Param:Format:Audio:AAC:streamFormat
    fn audio_aac_stream_format(&self) -> Option<SpaEnum<SpaAudioAacStreamFormat>> {
        self.get(SpaFormat::AudioAacStreamFormat)?
            .as_id()
            .map(SpaEnum::from_raw)
            .map_err(|err| {
                unreachable!(
                    "{}: {err}",
                    "Spa:Pod:Object:Param:Format:Audio:AAC:streamFormat"
                )
            })
            .ok()
    }
    /// Spa:Pod:Object:Param:Format:Audio:WMA:profile
    fn audio_wma_profile(&self) -> Option<SpaEnum<SpaAudioWmaProfile>> {
        self.get(SpaFormat::AudioWmaProfile)?
            .as_id()
            .map(SpaEnum::from_raw)
            .map_err(|err| {
                unreachable!("{}: {err}", "Spa:Pod:Object:Param:Format:Audio:WMA:profile")
            })
            .ok()
    }
    /// Spa:Pod:Object:Param:Format:Audio:AMR:bandMode
    fn audio_amr_band_mode(&self) -> Option<SpaEnum<SpaAudioAmrBandMode>> {
        self.get(SpaFormat::AudioAmrBandMode)?
            .as_id()
            .map(SpaEnum::from_raw)
            .map_err(|err| {
                unreachable!(
                    "{}: {err}",
                    "Spa:Pod:Object:Param:Format:Audio:AMR:bandMode"
                )
            })
            .ok()
    }
    /// Spa:Pod:Object:Param:Format:Video:format
    fn video_format(&self) -> Option<SpaEnum<SpaVideoFormat>> {
        self.get(SpaFormat::VideoFormat)?
            .as_id()
            .map(SpaEnum::from_raw)
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Format:Video:format"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Format:Video:modifier
    fn video_modifier(&self) -> Option<i64> {
        self.get(SpaFormat::VideoModifier)?
            .as_i64()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Format:Video:modifier"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Format:Video:size
    fn video_size(&self) -> Option<SpaRectangle> {
        self.get(SpaFormat::VideoSize)?
            .as_rectangle()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Format:Video:size"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Format:Video:framerate
    fn video_framerate(&self) -> Option<SpaFraction> {
        self.get(SpaFormat::VideoFramerate)?
            .as_fraction()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Format:Video:framerate"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Format:Video:maxFramerate
    fn video_max_framerate(&self) -> Option<SpaFraction> {
        self.get(SpaFormat::VideoMaxFramerate)?
            .as_fraction()
            .map_err(|err| {
                unreachable!(
                    "{}: {err}",
                    "Spa:Pod:Object:Param:Format:Video:maxFramerate"
                )
            })
            .ok()
    }
    /// Spa:Pod:Object:Param:Format:Video:views
    fn video_views(&self) -> Option<i32> {
        self.get(SpaFormat::VideoViews)?
            .as_i32()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Format:Video:views"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Format:Video:interlaceMode
    fn video_interlace_mode(&self) -> Option<SpaEnum<SpaVideoInterlaceMode>> {
        self.get(SpaFormat::VideoInterlaceMode)?
            .as_id()
            .map(SpaEnum::from_raw)
            .map_err(|err| {
                unreachable!(
                    "{}: {err}",
                    "Spa:Pod:Object:Param:Format:Video:interlaceMode"
                )
            })
            .ok()
    }
    /// Spa:Pod:Object:Param:Format:Video:pixelAspectRatio
    fn video_pixel_aspect_ratio(&self) -> Option<SpaFraction> {
        self.get(SpaFormat::VideoPixelAspectRatio)?
            .as_fraction()
            .map_err(|err| {
                unreachable!(
                    "{}: {err}",
                    "Spa:Pod:Object:Param:Format:Video:pixelAspectRatio"
                )
            })
            .ok()
    }
    /// Spa:Pod:Object:Param:Format:Video:multiviewMode
    fn video_multiview_mode(&self) -> Option<SpaEnum<SpaVideoMultiviewMode>> {
        self.get(SpaFormat::VideoMultiviewMode)?
            .as_id()
            .map(SpaEnum::from_raw)
            .map_err(|err| {
                unreachable!(
                    "{}: {err}",
                    "Spa:Pod:Object:Param:Format:Video:multiviewMode"
                )
            })
            .ok()
    }
    /// Spa:Pod:Object:Param:Format:Video:multiviewFlags
    fn video_multiview_flags(&self) -> Option<SpaEnum<SpaVideoMultiviewFlags>> {
        self.get(SpaFormat::VideoMultiviewFlags)?
            .as_id()
            .map(SpaEnum::from_raw)
            .map_err(|err| {
                unreachable!(
                    "{}: {err}",
                    "Spa:Pod:Object:Param:Format:Video:multiviewFlags"
                )
            })
            .ok()
    }
    /// Spa:Pod:Object:Param:Format:Video:chromaSite
    fn video_chroma_site(&self) -> Option<u32> {
        self.get(SpaFormat::VideoChromaSite)?
            .as_id()
            .map_err(|err| {
                unreachable!("{}: {err}", "Spa:Pod:Object:Param:Format:Video:chromaSite")
            })
            .ok()
    }
    /// Spa:Pod:Object:Param:Format:Video:colorRange
    fn video_color_range(&self) -> Option<u32> {
        self.get(SpaFormat::VideoColorRange)?
            .as_id()
            .map_err(|err| {
                unreachable!("{}: {err}", "Spa:Pod:Object:Param:Format:Video:colorRange")
            })
            .ok()
    }
    /// Spa:Pod:Object:Param:Format:Video:colorMatrix
    fn video_color_matrix(&self) -> Option<u32> {
        self.get(SpaFormat::VideoColorMatrix)?
            .as_id()
            .map_err(|err| {
                unreachable!("{}: {err}", "Spa:Pod:Object:Param:Format:Video:colorMatrix")
            })
            .ok()
    }
    /// Spa:Pod:Object:Param:Format:Video:transferFunction
    fn video_transfer_function(&self) -> Option<u32> {
        self.get(SpaFormat::VideoTransferFunction)?
            .as_id()
            .map_err(|err| {
                unreachable!(
                    "{}: {err}",
                    "Spa:Pod:Object:Param:Format:Video:transferFunction"
                )
            })
            .ok()
    }
    /// Spa:Pod:Object:Param:Format:Video:colorPrimaries
    fn video_color_primaries(&self) -> Option<u32> {
        self.get(SpaFormat::VideoColorPrimaries)?
            .as_id()
            .map_err(|err| {
                unreachable!(
                    "{}: {err}",
                    "Spa:Pod:Object:Param:Format:Video:colorPrimaries"
                )
            })
            .ok()
    }
    /// Spa:Pod:Object:Param:Format:Video:profile
    fn video_profile(&self) -> Option<i32> {
        self.get(SpaFormat::VideoProfile)?
            .as_i32()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Format:Video:profile"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Format:Video:level
    fn video_level(&self) -> Option<i32> {
        self.get(SpaFormat::VideoLevel)?
            .as_i32()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Format:Video:level"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Format:Video:H264:streamFormat
    fn video_h264_stream_format(&self) -> Option<u32> {
        self.get(SpaFormat::VideoH264StreamFormat)?
            .as_id()
            .map_err(|err| {
                unreachable!(
                    "{}: {err}",
                    "Spa:Pod:Object:Param:Format:Video:H264:streamFormat"
                )
            })
            .ok()
    }
    /// Spa:Pod:Object:Param:Format:Video:H264:alignment
    fn video_h264_alignment(&self) -> Option<u32> {
        self.get(SpaFormat::VideoH264Alignment)?
            .as_id()
            .map_err(|err| {
                unreachable!(
                    "{}: {err}",
                    "Spa:Pod:Object:Param:Format:Video:H264:alignment"
                )
            })
            .ok()
    }
}
impl<'a> std::fmt::Debug for Format<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut f = f.debug_struct("Format");
        obj_fmt!(
            f,
            self,
            media_type,
            media_subtype,
            audio_format,
            audio_flags,
            audio_rate,
            audio_channels,
            audio_position,
            audio_iec958_codec,
            audio_bitorder,
            audio_interleave,
            audio_bitrate,
            audio_block_align,
            audio_aac_stream_format,
            audio_wma_profile,
            audio_amr_band_mode,
            video_format,
            video_modifier,
            video_size,
            video_framerate,
            video_max_framerate,
            video_views,
            video_interlace_mode,
            video_pixel_aspect_ratio,
            video_multiview_mode,
            video_multiview_flags,
            video_chroma_site,
            video_color_range,
            video_color_matrix,
            video_transfer_function,
            video_color_primaries,
            video_profile,
            video_level,
            video_h264_stream_format,
            video_h264_alignment
        );
        f.finish()
    }
}

/// Spa:Pod:Object:Param:Buffers
pub struct Buffers<'a>(pub PodObjectDeserializer<'a>);
impl<'a> Buffers<'a> {
    fn get_raw(&self, id: u32) -> Option<PodDeserializer> {
        self.0.clone().find(|v| v.key == id).map(|v| v.value)
    }
    fn get(&self, key: SpaParamBuffers) -> Option<PodDeserializer> {
        self.get_raw(key.to_u32().unwrap())
    }
    /// Spa:Pod:Object:Param:Buffers:buffers
    fn buffers(&self) -> Option<i32> {
        self.get(SpaParamBuffers::Buffers)?
            .as_i32()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Buffers:buffers"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Buffers:blocks
    fn blocks(&self) -> Option<i32> {
        self.get(SpaParamBuffers::Blocks)?
            .as_i32()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Buffers:blocks"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Buffers:BlockInfo:size
    fn block_info_size(&self) -> Option<i32> {
        self.get(SpaParamBuffers::Size)?
            .as_i32()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Buffers:BlockInfo:size"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Buffers:BlockInfo:stride
    fn block_info_stride(&self) -> Option<i32> {
        self.get(SpaParamBuffers::Stride)?
            .as_i32()
            .map_err(|err| {
                unreachable!("{}: {err}", "Spa:Pod:Object:Param:Buffers:BlockInfo:stride")
            })
            .ok()
    }
    /// Spa:Pod:Object:Param:Buffers:BlockInfo:align
    fn block_info_align(&self) -> Option<i32> {
        self.get(SpaParamBuffers::Align)?
            .as_i32()
            .map_err(|err| {
                unreachable!("{}: {err}", "Spa:Pod:Object:Param:Buffers:BlockInfo:align")
            })
            .ok()
    }
    /// Spa:Pod:Object:Param:Buffers:BlockInfo:dataType
    fn block_info_data_type(&self) -> Option<i32> {
        self.get(SpaParamBuffers::DataType)?
            .as_i32()
            .map_err(|err| {
                unreachable!(
                    "{}: {err}",
                    "Spa:Pod:Object:Param:Buffers:BlockInfo:dataType"
                )
            })
            .ok()
    }
    /// Spa:Pod:Object:Param:Buffers:BlockInfo:metaType
    fn block_info_meta_type(&self) -> Option<i32> {
        self.get(SpaParamBuffers::MetaType)?
            .as_i32()
            .map_err(|err| {
                unreachable!(
                    "{}: {err}",
                    "Spa:Pod:Object:Param:Buffers:BlockInfo:metaType"
                )
            })
            .ok()
    }
}
impl<'a> std::fmt::Debug for Buffers<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut f = f.debug_struct("Buffers");
        obj_fmt!(
            f,
            self,
            buffers,
            blocks,
            block_info_size,
            block_info_stride,
            block_info_align,
            block_info_data_type,
            block_info_meta_type
        );
        f.finish()
    }
}

/// Spa:Pod:Object:Param:Meta
pub struct Meta<'a>(pub PodObjectDeserializer<'a>);
impl<'a> Meta<'a> {
    fn get_raw(&self, id: u32) -> Option<PodDeserializer> {
        self.0.clone().find(|v| v.key == id).map(|v| v.value)
    }
    fn get(&self, key: SpaParamMeta) -> Option<PodDeserializer> {
        self.get_raw(key.to_u32().unwrap())
    }
    /** Spa:Pod:Object:Param:Meta:type
        enum: Spa:Pointer:Meta
        value-0: "Spa:Pointer:Meta:Invalid"
        value-1: "Spa:Pointer:Meta:Header"
        value-2: "Spa:Pointer:Meta:Region:VideoCrop"
        value-3: "Spa:Pointer:Meta:Array:Region:VideoDamage"
        value-4: "Spa:Pointer:Meta:Bitmap"
        value-5: "Spa:Pointer:Meta:Cursor"
        value-6: "Spa:Pointer:Meta:Control"
        value-7: "Spa:Pointer:Meta:Busy"
        value-8: "Spa:Pointer:Meta:VideoTransform"
        value-9: "Spa:Pointer:Meta:SyncTimeline"
    */
    fn ty(&self) -> Option<u32> {
        self.get(SpaParamMeta::Type)?
            .as_id()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Meta:type"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Meta:size
    fn size(&self) -> Option<i32> {
        self.get(SpaParamMeta::Size)?
            .as_i32()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Meta:size"))
            .ok()
    }
}
impl<'a> std::fmt::Debug for Meta<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut f = f.debug_struct("Meta");
        obj_fmt!(f, self, ty, size);
        f.finish()
    }
}

/// Spa:Pod:Object:Param:IO
pub struct Io<'a>(pub PodObjectDeserializer<'a>);
impl<'a> Io<'a> {
    fn get_raw(&self, id: u32) -> Option<PodDeserializer> {
        self.0.clone().find(|v| v.key == id).map(|v| v.value)
    }
    fn get(&self, key: SpaParamIo) -> Option<PodDeserializer> {
        self.get_raw(key.to_u32().unwrap())
    }
    /** Spa:Pod:Object:Param:IO:id
        enum: Spa:Enum:IO
        value-0: "Spa:Enum:IO:Invalid"
        value-1: "Spa:Enum:IO:Buffers"
        value-2: "Spa:Enum:IO:Range"
        value-3: "Spa:Enum:IO:Clock"
        value-4: "Spa:Enum:IO:Latency"
        value-5: "Spa:Enum:IO:Control"
        value-6: "Spa:Enum:IO:Notify"
        value-7: "Spa:Enum:IO:Position"
        value-8: "Spa:Enum:IO:RateMatch"
        value-9: "Spa:Enum:IO:Memory"
        value-10: "Spa:Enum:IO:AsyncBuffers"
    */
    fn id(&self) -> Option<u32> {
        self.get(SpaParamIo::Id)?
            .as_id()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:IO:id"))
            .ok()
    }
    /// Spa:Pod:Object:Param:IO:size
    fn size(&self) -> Option<i32> {
        self.get(SpaParamIo::Size)?
            .as_i32()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:IO:size"))
            .ok()
    }
}
impl<'a> std::fmt::Debug for Io<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut f = f.debug_struct("Io");
        obj_fmt!(f, self, id, size);
        f.finish()
    }
}

/// Spa:Pod:Object:Param:Profile
pub struct Profile<'a>(pub PodObjectDeserializer<'a>);
impl<'a> Profile<'a> {
    fn get_raw(&self, id: u32) -> Option<PodDeserializer> {
        self.0.clone().find(|v| v.key == id).map(|v| v.value)
    }
    fn get(&self, key: SpaParamProfile) -> Option<PodDeserializer> {
        self.get_raw(key.to_u32().unwrap())
    }
    /// Spa:Pod:Object:Param:Profile:index
    fn index(&self) -> Option<i32> {
        self.get(SpaParamProfile::Index)?
            .as_i32()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Profile:index"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Profile:name
    fn name(&self) -> Option<&BStr> {
        self.get(SpaParamProfile::Name)?
            .as_str()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Profile:name"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Profile:description
    fn description(&self) -> Option<&BStr> {
        self.get(SpaParamProfile::Description)?
            .as_str()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Profile:description"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Profile:priority
    fn priority(&self) -> Option<i32> {
        self.get(SpaParamProfile::Priority)?
            .as_i32()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Profile:priority"))
            .ok()
    }
    /** Spa:Pod:Object:Param:Profile:available
        enum: Spa:Enum:ParamAvailability
        value-0: "Spa:Enum:ParamAvailability:unknown"
        value-1: "Spa:Enum:ParamAvailability:no"
        value-2: "Spa:Enum:ParamAvailability:yes"
    */
    fn available(&self) -> Option<u32> {
        self.get(SpaParamProfile::Available)?
            .as_id()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Profile:available"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Profile:info
    fn info(&self) -> Option<PodStructDeserializer> {
        self.get(SpaParamProfile::Info)?
            .as_struct()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Profile:info"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Profile:classes
    fn classes(&self) -> Option<PodStructDeserializer> {
        self.get(SpaParamProfile::Classes)?
            .as_struct()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Profile:classes"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Profile:save
    fn save(&self) -> Option<bool> {
        self.get(SpaParamProfile::Save)?
            .as_bool()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Profile:save"))
            .ok()
    }
}
impl<'a> std::fmt::Debug for Profile<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut f = f.debug_struct("Profile");
        obj_fmt!(
            f,
            self,
            index,
            name,
            description,
            priority,
            available,
            info,
            classes,
            save
        );
        f.finish()
    }
}

/// Spa:Pod:Object:Param:PortConfig
pub struct PortConfig<'a>(pub PodObjectDeserializer<'a>);
impl<'a> PortConfig<'a> {
    fn get_raw(&self, id: u32) -> Option<PodDeserializer> {
        self.0.clone().find(|v| v.key == id).map(|v| v.value)
    }
    fn get(&self, key: SpaParamPortConfig) -> Option<PodDeserializer> {
        self.get_raw(key.to_u32().unwrap())
    }
    /// Spa:Pod:Object:Param:PortConfig:direction
    fn direction(&self) -> Option<SpaEnum<SpaDirection>> {
        self.get(SpaParamPortConfig::Direction)?
            .as_id()
            .map(SpaEnum::from_raw)
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:PortConfig:direction"))
            .ok()
    }
    /// Spa:Pod:Object:Param:PortConfig:mode
    fn mode(&self) -> Option<SpaEnum<SpaParamPortConfigMode>> {
        self.get(SpaParamPortConfig::Mode)?
            .as_id()
            .map(SpaEnum::from_raw)
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:PortConfig:mode"))
            .ok()
    }
    /// Spa:Pod:Object:Param:PortConfig:monitor
    fn monitor(&self) -> Option<bool> {
        self.get(SpaParamPortConfig::Monitor)?
            .as_bool()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:PortConfig:monitor"))
            .ok()
    }
    /// Spa:Pod:Object:Param:PortConfig:control
    fn control(&self) -> Option<bool> {
        self.get(SpaParamPortConfig::Control)?
            .as_bool()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:PortConfig:control"))
            .ok()
    }
    /// Spa:Pod:Object:Param:PortConfig:format
    fn format(&self) -> Option<Format> {
        self.get(SpaParamPortConfig::Format)?
            .as_object()
            .map(Format)
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:PortConfig:format"))
            .ok()
    }
}
impl<'a> std::fmt::Debug for PortConfig<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut f = f.debug_struct("PortConfig");
        obj_fmt!(f, self, direction, mode, monitor, control, format);
        f.finish()
    }
}

/// Spa:Pod:Object:Param:Route
pub struct Route<'a>(pub PodObjectDeserializer<'a>);
impl<'a> Route<'a> {
    fn get_raw(&self, id: u32) -> Option<PodDeserializer> {
        self.0.clone().find(|v| v.key == id).map(|v| v.value)
    }
    fn get(&self, key: SpaParamRoute) -> Option<PodDeserializer> {
        self.get_raw(key.to_u32().unwrap())
    }
    /// Spa:Pod:Object:Param:Route:index
    fn index(&self) -> Option<i32> {
        self.get(SpaParamRoute::Index)?
            .as_i32()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Route:index"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Route:direction
    fn direction(&self) -> Option<SpaEnum<SpaDirection>> {
        self.get(SpaParamRoute::Direction)?
            .as_id()
            .map(SpaEnum::from_raw)
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Route:direction"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Route:device
    fn device(&self) -> Option<i32> {
        self.get(SpaParamRoute::Device)?
            .as_i32()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Route:device"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Route:name
    fn name(&self) -> Option<&BStr> {
        self.get(SpaParamRoute::Name)?
            .as_str()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Route:name"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Route:description
    fn description(&self) -> Option<&BStr> {
        self.get(SpaParamRoute::Description)?
            .as_str()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Route:description"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Route:priority
    fn priority(&self) -> Option<i32> {
        self.get(SpaParamRoute::Priority)?
            .as_i32()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Route:priority"))
            .ok()
    }
    /** Spa:Pod:Object:Param:Route:available
        enum: Spa:Enum:ParamAvailability
        value-0: "Spa:Enum:ParamAvailability:unknown"
        value-1: "Spa:Enum:ParamAvailability:no"
        value-2: "Spa:Enum:ParamAvailability:yes"
    */
    fn available(&self) -> Option<u32> {
        self.get(SpaParamRoute::Available)?
            .as_id()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Route:available"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Route:info
    fn info(&self) -> Option<PodStructDeserializer> {
        self.get(SpaParamRoute::Info)?
            .as_struct()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Route:info"))
            .ok()
    }
    /** Spa:Pod:Object:Param:Route:profiles
        parent: Array<Spa:intArray>
    */
    fn profiles(&self) -> Option<PodArrayDeserializer> {
        self.get(SpaParamRoute::Profiles)?
            .as_array()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Route:profiles"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Route:props
    fn props(&self) -> Option<Props> {
        self.get(SpaParamRoute::Props)?
            .as_object()
            .map(Props)
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Route:props"))
            .ok()
    }
    /** Spa:Pod:Object:Param:Route:devices
        parent: Array<Spa:intArray>
    */
    fn devices(&self) -> Option<PodArrayDeserializer> {
        self.get(SpaParamRoute::Devices)?
            .as_array()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Route:devices"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Route:profile
    fn profile(&self) -> Option<i32> {
        self.get(SpaParamRoute::Profile)?
            .as_i32()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Route:profile"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Route:save
    fn save(&self) -> Option<bool> {
        self.get(SpaParamRoute::Save)?
            .as_bool()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Route:save"))
            .ok()
    }
}
impl<'a> std::fmt::Debug for Route<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut f = f.debug_struct("Route");
        obj_fmt!(
            f,
            self,
            index,
            direction,
            device,
            name,
            description,
            priority,
            available,
            info,
            profiles,
            props,
            devices,
            profile,
            save
        );
        f.finish()
    }
}

/// Spa:Pod:Object:Profiler
pub struct Profiler<'a>(pub PodObjectDeserializer<'a>);
impl<'a> Profiler<'a> {
    fn get_raw(&self, id: u32) -> Option<PodDeserializer> {
        self.0.clone().find(|v| v.key == id).map(|v| v.value)
    }
    fn get(&self, key: SpaProfiler) -> Option<PodDeserializer> {
        self.get_raw(key.to_u32().unwrap())
    }
    /// Spa:Pod:Object:Profiler:info
    fn info(&self) -> Option<PodStructDeserializer> {
        self.get(SpaProfiler::Info)?
            .as_struct()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Profiler:info"))
            .ok()
    }
    /// Spa:Pod:Object:Profiler:clock
    fn clock(&self) -> Option<PodStructDeserializer> {
        self.get(SpaProfiler::Clock)?
            .as_struct()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Profiler:clock"))
            .ok()
    }
    /// Spa:Pod:Object:Profiler:driverBlock
    fn driver_block(&self) -> Option<PodStructDeserializer> {
        self.get(SpaProfiler::DriverBlock)?
            .as_struct()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Profiler:driverBlock"))
            .ok()
    }
    /// Spa:Pod:Object:Profiler:followerBlock
    fn follower_block(&self) -> Option<PodStructDeserializer> {
        self.get(SpaProfiler::FollowerBlock)?
            .as_struct()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Profiler:followerBlock"))
            .ok()
    }
    /// Spa:Pod:Object:Profiler:followerClock
    fn follower_clock(&self) -> Option<PodStructDeserializer> {
        self.get_raw(131074u32)?
            .as_struct()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Profiler:followerClock"))
            .ok()
    }
}
impl<'a> std::fmt::Debug for Profiler<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut f = f.debug_struct("Profiler");
        obj_fmt!(
            f,
            self,
            info,
            clock,
            driver_block,
            follower_block,
            follower_clock
        );
        f.finish()
    }
}

/// Spa:Pod:Object:Param:Latency
pub struct Latency<'a>(pub PodObjectDeserializer<'a>);
impl<'a> Latency<'a> {
    fn get_raw(&self, id: u32) -> Option<PodDeserializer> {
        self.0.clone().find(|v| v.key == id).map(|v| v.value)
    }
    fn get(&self, key: SpaParamLatency) -> Option<PodDeserializer> {
        self.get_raw(key.to_u32().unwrap())
    }
    /// Spa:Pod:Object:Param:Latency:direction
    fn direction(&self) -> Option<SpaEnum<SpaDirection>> {
        self.get(SpaParamLatency::Direction)?
            .as_id()
            .map(SpaEnum::from_raw)
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Latency:direction"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Latency:minQuantum
    fn min_quantum(&self) -> Option<f32> {
        self.get(SpaParamLatency::MinQuantum)?
            .as_f32()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Latency:minQuantum"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Latency:maxQuantum
    fn max_quantum(&self) -> Option<f32> {
        self.get(SpaParamLatency::MaxQuantum)?
            .as_f32()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Latency:maxQuantum"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Latency:minRate
    fn min_rate(&self) -> Option<i32> {
        self.get(SpaParamLatency::MinRate)?
            .as_i32()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Latency:minRate"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Latency:maxRate
    fn max_rate(&self) -> Option<i32> {
        self.get(SpaParamLatency::MaxRate)?
            .as_i32()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Latency:maxRate"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Latency:minNs
    fn min_ns(&self) -> Option<i64> {
        self.get(SpaParamLatency::MinNs)?
            .as_i64()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Latency:minNs"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Latency:maxNs
    fn max_ns(&self) -> Option<i64> {
        self.get(SpaParamLatency::MaxNs)?
            .as_i64()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Latency:maxNs"))
            .ok()
    }
}
impl<'a> std::fmt::Debug for Latency<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut f = f.debug_struct("Latency");
        obj_fmt!(
            f,
            self,
            direction,
            min_quantum,
            max_quantum,
            min_rate,
            max_rate,
            min_ns,
            max_ns
        );
        f.finish()
    }
}

/// Spa:Pod:Object:Param:ProcessLatency
pub struct ProcessLatency<'a>(pub PodObjectDeserializer<'a>);
impl<'a> ProcessLatency<'a> {
    fn get_raw(&self, id: u32) -> Option<PodDeserializer> {
        self.0.clone().find(|v| v.key == id).map(|v| v.value)
    }
    fn get(&self, key: SpaParamProcessLatency) -> Option<PodDeserializer> {
        self.get_raw(key.to_u32().unwrap())
    }
    /// Spa:Pod:Object:Param:ProcessLatency:quantum
    fn quantum(&self) -> Option<f32> {
        self.get(SpaParamProcessLatency::Quantum)?
            .as_f32()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:ProcessLatency:quantum"))
            .ok()
    }
    /// Spa:Pod:Object:Param:ProcessLatency:rate
    fn rate(&self) -> Option<i32> {
        self.get(SpaParamProcessLatency::Rate)?
            .as_i32()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:ProcessLatency:rate"))
            .ok()
    }
    /// Spa:Pod:Object:Param:ProcessLatency:ns
    fn ns(&self) -> Option<i64> {
        self.get(SpaParamProcessLatency::Ns)?
            .as_i64()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:ProcessLatency:ns"))
            .ok()
    }
}
impl<'a> std::fmt::Debug for ProcessLatency<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut f = f.debug_struct("ProcessLatency");
        obj_fmt!(f, self, quantum, rate, ns);
        f.finish()
    }
}

/// Spa:Pod:Object:Param:Tag
pub struct Tag<'a>(pub PodObjectDeserializer<'a>);
impl<'a> Tag<'a> {
    fn get_raw(&self, id: u32) -> Option<PodDeserializer> {
        self.0.clone().find(|v| v.key == id).map(|v| v.value)
    }
    fn get(&self, key: SpaParamTag) -> Option<PodDeserializer> {
        self.get_raw(key.to_u32().unwrap())
    }
    /// Spa:Pod:Object:Param:Tag:direction
    fn direction(&self) -> Option<SpaEnum<SpaDirection>> {
        self.get(SpaParamTag::Direction)?
            .as_id()
            .map(SpaEnum::from_raw)
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Tag:direction"))
            .ok()
    }
    /// Spa:Pod:Object:Param:Tag:info
    fn info(&self) -> Option<PodStructDeserializer> {
        self.get(SpaParamTag::Info)?
            .as_struct()
            .map_err(|err| unreachable!("{}: {err}", "Spa:Pod:Object:Param:Tag:info"))
            .ok()
    }
}
impl<'a> std::fmt::Debug for Tag<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut f = f.debug_struct("Tag");
        obj_fmt!(f, self, direction, info);
        f.finish()
    }
}
