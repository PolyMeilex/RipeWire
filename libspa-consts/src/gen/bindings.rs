/* automatically generated by rust-bindgen 0.69.4 */

#[repr(u32)]
#[derive(
    Debug, Copy, Clone, Hash, PartialEq, Eq, num_derive :: FromPrimitive, num_derive :: ToPrimitive,
)]
pub enum SpaDirection {
    Input = 0,
    Output = 1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct SpaRectangle {
    pub width: u32,
    pub height: u32,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct SpaFraction {
    pub num: u32,
    pub denom: u32,
}
#[repr(u32)]
#[derive(
    Debug, Copy, Clone, Hash, PartialEq, Eq, num_derive :: FromPrimitive, num_derive :: ToPrimitive,
)]
pub enum SpaChoiceType {
    #[doc = "< no choice, first value is current"]
    None = 0,
    #[doc = "< range: default, min, max"]
    Range = 1,
    #[doc = "< range with step: default, min, max, step"]
    Step = 2,
    #[doc = "< list: default, alternative,..."]
    Enum = 3,
    #[doc = "< flags: default, possible flags,..."]
    Flags = 4,
}
#[repr(u32)]
#[doc = " \\addtogroup spa_buffer\n \\{"]
#[derive(
    Debug, Copy, Clone, Hash, PartialEq, Eq, num_derive :: FromPrimitive, num_derive :: ToPrimitive,
)]
pub enum SpaMetaType {
    Invalid = 0,
    #[doc = "< struct spa_meta_header"]
    Header = 1,
    #[doc = "< struct spa_meta_region with cropping data"]
    VideoCrop = 2,
    #[doc = "< array of struct spa_meta_region with damage, where an invalid entry or end-of-array marks the end."]
    VideoDamage = 3,
    #[doc = "< struct spa_meta_bitmap"]
    Bitmap = 4,
    #[doc = "< struct spa_meta_cursor"]
    Cursor = 5,
    #[doc = "< metadata contains a spa_meta_control\n  associated with the data"]
    Control = 6,
    #[doc = "< don't write to buffer when count > 0"]
    Busy = 7,
    #[doc = "< struct spa_meta_transform"]
    VideoTransform = 8,
    #[doc = "< struct spa_meta_sync_timeline"]
    SyncTimeline = 9,
    #[doc = "< not part of ABI/API"]
    _SPA_META_LAST = 10,
}
#[repr(u32)]
#[doc = " \\addtogroup spa_buffer\n \\{"]
#[derive(
    Debug, Copy, Clone, Hash, PartialEq, Eq, num_derive :: FromPrimitive, num_derive :: ToPrimitive,
)]
pub enum SpaDataType {
    Invalid = 0,
    #[doc = "< pointer to memory, the data field in\n  struct spa_data is set."]
    MemPtr = 1,
    #[doc = "< memfd, mmap to get to memory."]
    MemFd = 2,
    #[doc = "< fd to dmabuf memory. This might not be readily\n  mappable (unless the MAPPABLE flag is set) and should\n  normally be handled with DMABUF apis."]
    DmaBuf = 3,
    #[doc = "< memory is identified with an id. The actual memory\n  can be obtained in some other way and can be identified\n  with this id."]
    MemId = 4,
    #[doc = "< a syncobj, usually requires a spa_meta_sync_timeline metadata\n  with timeline points."]
    SyncObj = 5,
}
#[repr(u32)]
#[doc = " Different Control types"]
#[derive(
    Debug, Copy, Clone, Hash, PartialEq, Eq, num_derive :: FromPrimitive, num_derive :: ToPrimitive,
)]
pub enum SpaControlType {
    Invalid = 0,
    #[doc = "< data contains a SPA_TYPE_OBJECT_Props"]
    Properties = 1,
    #[doc = "< data contains a spa_pod_bytes with raw midi data"]
    Midi = 2,
    #[doc = "< data contains a spa_pod_bytes with an OSC packet"]
    Osc = 3,
    #[doc = "< not part of ABI"]
    _SPA_CONTROL_LAST = 4,
}
#[repr(u32)]
#[doc = " Different IO area types"]
#[derive(
    Debug, Copy, Clone, Hash, PartialEq, Eq, num_derive :: FromPrimitive, num_derive :: ToPrimitive,
)]
pub enum SpaIoType {
    Invalid = 0,
    #[doc = "< area to exchange buffers, struct spa_io_buffers"]
    Buffers = 1,
    #[doc = "< expected byte range, struct spa_io_range (currently not used in PipeWire)"]
    Range = 2,
    #[doc = "< area to update clock information, struct spa_io_clock"]
    Clock = 3,
    #[doc = "< latency reporting, struct spa_io_latency (currently not used in\n PipeWire). \\see spa_param_latency"]
    Latency = 4,
    #[doc = "< area for control messages, struct spa_io_sequence"]
    Control = 5,
    #[doc = "< area for notify messages, struct spa_io_sequence"]
    Notify = 6,
    #[doc = "< position information in the graph, struct spa_io_position"]
    Position = 7,
    #[doc = "< rate matching between nodes, struct spa_io_rate_match"]
    RateMatch = 8,
    #[doc = "< memory pointer, struct spa_io_memory (currently not used in PipeWire)"]
    Memory = 9,
    #[doc = "< async area to exchange buffers, struct spa_io_async_buffers"]
    AsyncBuffers = 10,
}
#[doc = " Absolute time reporting.\n\n Nodes that can report clocking information will receive this io block.\n The application sets the id. This is usually set as part of the\n position information but can also be set separately.\n\n The clock counts the elapsed time according to the clock provider\n since the provider was last started.\n\n Driver nodes are supposed to update the contents of \\ref SPA_IO_Clock before\n signaling the start of a graph cycle.  These updated clock values become\n visible to other nodes in \\ref SPA_IO_Position. Non-driver nodes do\n not need to update the contents of their \\ref SPA_IO_Clock.\n\n The host generally gives each node a separate \\ref spa_io_clock in \\ref\n SPA_IO_Clock, so that updates made by the driver are not visible in the\n contents of \\ref SPA_IO_Clock of other nodes. Instead, \\ref SPA_IO_Position\n is used to look up the current graph time.\n\n A node is a driver when \\ref spa_io_clock.id in \\ref SPA_IO_Clock and\n \\ref spa_io_position.clock.id in \\ref SPA_IO_Position are the same."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SpaIoClock {
    #[doc = "< Clock flags"]
    pub flags: u32,
    #[doc = "< Unique clock id, set by host application"]
    pub id: u32,
    #[doc = "< Clock name prefixed with API, set by node when it receives\n  \\ref SPA_IO_Clock. The clock name is unique per clock and\n  can be used to check if nodes share the same clock."]
    pub name: [::std::os::raw::c_char; 64usize],
    #[doc = "< Time in nanoseconds against monotonic clock\n (CLOCK_MONOTONIC). This fields reflects a real time instant\n in the past. The value may have jitter."]
    pub nsec: u64,
    #[doc = "< Rate for position/duration/delay/xrun"]
    pub rate: SpaFraction,
    #[doc = "< Current position, in samples @ \\ref rate"]
    pub position: u64,
    #[doc = "< Duration of current cycle, in samples @ \\ref rate"]
    pub duration: u64,
    #[doc = "< Delay between position and hardware, in samples @ \\ref rate"]
    pub delay: i64,
    #[doc = "< Rate difference between clock and monotonic time, as a ratio of\n  clock speeds."]
    pub rate_diff: f64,
    #[doc = "< Estimated next wakeup time in nanoseconds.\n  This time is a logical start time of the next cycle, and\n  is not necessarily in the future."]
    pub next_nsec: u64,
    #[doc = "< Target rate of next cycle"]
    pub target_rate: SpaFraction,
    #[doc = "< Target duration of next cycle"]
    pub target_duration: u64,
    #[doc = "< Seq counter. must be equal at start and\n  end of read and lower bit must be 0"]
    pub target_seq: u32,
    #[doc = "< incremented each time the graph is started"]
    pub cycle: u32,
    #[doc = "< Estimated accumulated xrun duration"]
    pub xrun: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct SpaIoVideoSize {
    #[doc = "< optional flags"]
    pub flags: u32,
    #[doc = "< video stride in bytes"]
    pub stride: u32,
    #[doc = "< the video size"]
    pub size: SpaRectangle,
    #[doc = "< the minimum framerate, the cycle duration is\n  always smaller to ensure there is only one\n  video frame per cycle."]
    pub framerate: SpaFraction,
    pub padding: [u32; 4usize],
}
#[doc = " bar and beat segment"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SpaIoSegmentBar {
    #[doc = "< extra flags"]
    pub flags: u32,
    #[doc = "< offset in segment of this beat"]
    pub offset: u32,
    #[doc = "< time signature numerator"]
    pub signature_num: f32,
    #[doc = "< time signature denominator"]
    pub signature_denom: f32,
    #[doc = "< beats per minute"]
    pub bpm: f64,
    #[doc = "< current beat in segment"]
    pub beat: f64,
    pub bar_start_tick: f64,
    pub ticks_per_beat: f64,
    pub padding: [u32; 4usize],
}
#[doc = " video frame segment"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct SpaIoSegmentVideo {
    #[doc = "< flags"]
    pub flags: u32,
    #[doc = "< offset in segment"]
    pub offset: u32,
    pub framerate: SpaFraction,
    pub hours: u32,
    pub minutes: u32,
    pub seconds: u32,
    pub frames: u32,
    #[doc = "< 0 for progressive, 1 and 2 for interlaced"]
    pub field_count: u32,
    pub padding: [u32; 11usize],
}
#[doc = " A segment converts a running time to a segment (stream) position.\n\n The segment position is valid when the current running time is between\n start and start + duration. The position is then\n calculated as:\n\n   (running time - start) * rate + position;\n\n Support for looping is done by specifying the LOOPING flags with a\n non-zero duration. When the running time reaches start + duration,\n duration is added to start and the loop repeats.\n\n Care has to be taken when the running time + clock.duration extends\n past the start + duration from the segment; the user should correctly\n wrap around and partially repeat the loop in the current cycle.\n\n Extra information can be placed in the segment by setting the valid flags\n and filling up the corresponding structures."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SpaIoSegment {
    pub version: u32,
    #[doc = "< extra flags"]
    pub flags: u32,
    #[doc = "< value of running time when this\n  info is active. Can be in the future for\n  pending changes. It does not have to be in\n  exact multiples of the clock duration."]
    pub start: u64,
    #[doc = "< duration when this info becomes invalid expressed\n  in running time. If the duration is 0, this\n  segment extends to the next segment. If the\n  segment becomes invalid and the looping flag is\n  set, the segment repeats."]
    pub duration: u64,
    #[doc = "< overall rate of the segment, can be negative for\n  backwards time reporting."]
    pub rate: f64,
    #[doc = "< The position when the running time == start.\n  can be invalid when the owner of the extra segment\n  information has not yet made the mapping."]
    pub position: u64,
    pub bar: SpaIoSegmentBar,
    pub video: SpaIoSegmentVideo,
}
#[doc = " The position information adds extra meaning to the raw clock times.\n\n It is set on all nodes in \\ref SPA_IO_Position, and the contents of \\ref\n spa_io_position.clock contain the clock updates made by the driving node in\n the graph in its \\ref SPA_IO_Clock.  Also, \\ref spa_io_position.clock.id\n will contain the clock id of the driving node in the graph.\n\n The position clock indicates the logical start time of the current graph\n cycle.\n\n The position information contains 1 or more segments that convert the\n raw clock times to a stream time. They are sorted based on their\n start times, and thus the order in which they will activate in\n the future. This makes it possible to look ahead in the scheduled\n segments and anticipate the changes in the timeline."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct SpaIoPosition {
    #[doc = "< clock position of driver, always valid and\n  read only"]
    pub clock: SpaIoClock,
    #[doc = "< size of the video in the current cycle"]
    pub video: SpaIoVideoSize,
    #[doc = "< an offset to subtract from the clock position\n  to get a running time. This is the time that\n  the state has been in the RUNNING state and the\n  time that should be used to compare the segment\n  start values against."]
    pub offset: i64,
    #[doc = "< one of enum spa_io_position_state"]
    pub state: u32,
    #[doc = "< number of segments"]
    pub n_segments: u32,
    #[doc = "< segments"]
    pub segments: [SpaIoSegment; 8usize],
}
#[repr(u32)]
#[doc = " different parameter types that can be queried"]
#[derive(
    Debug, Copy, Clone, Hash, PartialEq, Eq, num_derive :: FromPrimitive, num_derive :: ToPrimitive,
)]
pub enum SpaParamType {
    #[doc = "< invalid"]
    Invalid = 0,
    #[doc = "< property information as SPA_TYPE_OBJECT_PropInfo"]
    PropInfo = 1,
    #[doc = "< properties as SPA_TYPE_OBJECT_Props"]
    Props = 2,
    #[doc = "< available formats as SPA_TYPE_OBJECT_Format"]
    EnumFormat = 3,
    #[doc = "< configured format as SPA_TYPE_OBJECT_Format"]
    Format = 4,
    #[doc = "< buffer configurations as SPA_TYPE_OBJECT_ParamBuffers"]
    Buffers = 5,
    #[doc = "< allowed metadata for buffers as SPA_TYPE_OBJECT_ParamMeta"]
    Meta = 6,
    #[doc = "< configurable IO areas as SPA_TYPE_OBJECT_ParamIO"]
    Io = 7,
    #[doc = "< profile enumeration as SPA_TYPE_OBJECT_ParamProfile"]
    EnumProfile = 8,
    #[doc = "< profile configuration as SPA_TYPE_OBJECT_ParamProfile"]
    Profile = 9,
    #[doc = "< port configuration enumeration as SPA_TYPE_OBJECT_ParamPortConfig"]
    EnumPortConfig = 10,
    #[doc = "< port configuration as SPA_TYPE_OBJECT_ParamPortConfig"]
    PortConfig = 11,
    #[doc = "< routing enumeration as SPA_TYPE_OBJECT_ParamRoute"]
    EnumRoute = 12,
    #[doc = "< routing configuration as SPA_TYPE_OBJECT_ParamRoute"]
    Route = 13,
    #[doc = "< Control parameter, a SPA_TYPE_Sequence"]
    Control = 14,
    #[doc = "< latency reporting, a SPA_TYPE_OBJECT_ParamLatency"]
    Latency = 15,
    #[doc = "< processing latency, a SPA_TYPE_OBJECT_ParamProcessLatency"]
    ProcessLatency = 16,
    #[doc = "< tag reporting, a SPA_TYPE_OBJECT_ParamTag. Since 0.3.79"]
    Tag = 17,
}
#[repr(u32)]
#[derive(
    Debug, Copy, Clone, Hash, PartialEq, Eq, num_derive :: FromPrimitive, num_derive :: ToPrimitive,
)]
pub enum SpaParamAvailability {
    #[doc = "< unknown availability"]
    Unknown = 0,
    #[doc = "< not available"]
    No = 1,
    #[doc = "< available"]
    Yes = 2,
}
#[repr(u32)]
#[doc = " properties for SPA_TYPE_OBJECT_ParamBuffers"]
#[derive(
    Debug, Copy, Clone, Hash, PartialEq, Eq, num_derive :: FromPrimitive, num_derive :: ToPrimitive,
)]
pub enum SpaParamBuffers {
    Start = 0,
    #[doc = "< number of buffers (Int)"]
    Buffers = 1,
    #[doc = "< number of data blocks per buffer (Int)"]
    Blocks = 2,
    #[doc = "< size of a data block memory (Int)"]
    Size = 3,
    #[doc = "< stride of data block memory (Int)"]
    Stride = 4,
    #[doc = "< alignment of data block memory (Int)"]
    Align = 5,
    #[doc = "< possible memory types (flags choice Int, mask of enum spa_data_type)"]
    DataType = 6,
    #[doc = "< required meta data types (Int, mask of enum spa_meta_type)"]
    MetaType = 7,
}
#[repr(u32)]
#[doc = " properties for SPA_TYPE_OBJECT_ParamMeta"]
#[derive(
    Debug, Copy, Clone, Hash, PartialEq, Eq, num_derive :: FromPrimitive, num_derive :: ToPrimitive,
)]
pub enum SpaParamMeta {
    Start = 0,
    #[doc = "< the metadata, one of enum spa_meta_type (Id enum spa_meta_type)"]
    Type = 1,
    #[doc = "< the expected maximum size the meta (Int)"]
    Size = 2,
}
#[repr(u32)]
#[doc = " properties for SPA_TYPE_OBJECT_ParamIO"]
#[derive(
    Debug, Copy, Clone, Hash, PartialEq, Eq, num_derive :: FromPrimitive, num_derive :: ToPrimitive,
)]
pub enum SpaParamIo {
    Start = 0,
    #[doc = "< type ID, uniquely identifies the io area (Id enum spa_io_type)"]
    Id = 1,
    #[doc = "< size of the io area (Int)"]
    Size = 2,
}
#[repr(u32)]
#[doc = " properties for SPA_TYPE_OBJECT_ParamProfile"]
#[derive(
    Debug, Copy, Clone, Hash, PartialEq, Eq, num_derive :: FromPrimitive, num_derive :: ToPrimitive,
)]
pub enum SpaParamProfile {
    Start = 0,
    #[doc = "< profile index (Int)"]
    Index = 1,
    #[doc = "< profile name (String)"]
    Name = 2,
    #[doc = "< profile description (String)"]
    Description = 3,
    #[doc = "< profile priority (Int)"]
    Priority = 4,
    #[doc = "< availability of the profile\n  (Id enum spa_param_availability)"]
    Available = 5,
    #[doc = "< info (Struct(\n\t\t  Int : n_items,\n\t\t  (String : key,\n\t\t   String : value)*))"]
    Info = 6,
    #[doc = "< node classes provided by this profile\n  (Struct(\n\t   Int : number of items following\n        Struct(\n           String : class name (eg. \"Audio/Source\"),\n           Int : number of nodes\n           String : property (eg. \"card.profile.devices\"),\n           Array of Int: device indexes\n         )*))"]
    Classes = 7,
    #[doc = "< If profile should be saved (Bool)"]
    Save = 8,
}
#[repr(u32)]
#[derive(
    Debug, Copy, Clone, Hash, PartialEq, Eq, num_derive :: FromPrimitive, num_derive :: ToPrimitive,
)]
pub enum SpaParamPortConfigMode {
    #[doc = "< no configuration"]
    None = 0,
    #[doc = "< passthrough configuration"]
    Passthrough = 1,
    #[doc = "< convert configuration"]
    Convert = 2,
    #[doc = "< dsp configuration, depending on the external\n  format. For audio, ports will be configured for\n  the given number of channels with F32 format."]
    Dsp = 3,
}
#[repr(u32)]
#[doc = " properties for SPA_TYPE_OBJECT_ParamPortConfig"]
#[derive(
    Debug, Copy, Clone, Hash, PartialEq, Eq, num_derive :: FromPrimitive, num_derive :: ToPrimitive,
)]
pub enum SpaParamPortConfig {
    Start = 0,
    #[doc = "< (Id enum spa_direction) direction"]
    Direction = 1,
    #[doc = "< (Id enum spa_param_port_config_mode) mode"]
    Mode = 2,
    #[doc = "< (Bool) enable monitor output ports on input ports"]
    Monitor = 3,
    #[doc = "< (Bool) enable control ports"]
    Control = 4,
    #[doc = "< (Object) format filter"]
    Format = 5,
}
#[repr(u32)]
#[doc = " properties for SPA_TYPE_OBJECT_ParamRoute"]
#[derive(
    Debug, Copy, Clone, Hash, PartialEq, Eq, num_derive :: FromPrimitive, num_derive :: ToPrimitive,
)]
pub enum SpaParamRoute {
    Start = 0,
    #[doc = "< index of the routing destination (Int)"]
    Index = 1,
    #[doc = "< direction, input/output (Id enum spa_direction)"]
    Direction = 2,
    #[doc = "< device id (Int)"]
    Device = 3,
    #[doc = "< name of the routing destination (String)"]
    Name = 4,
    #[doc = "< description of the destination (String)"]
    Description = 5,
    #[doc = "< priority of the destination (Int)"]
    Priority = 6,
    #[doc = "< availability of the destination\n  (Id enum spa_param_availability)"]
    Available = 7,
    #[doc = "< info (Struct(\n\t\t  Int : n_items,\n\t\t  (String : key,\n\t\t   String : value)*))"]
    Info = 8,
    #[doc = "< associated profile indexes (Array of Int)"]
    Profiles = 9,
    #[doc = "< properties SPA_TYPE_OBJECT_Props"]
    Props = 10,
    #[doc = "< associated device indexes (Array of Int)"]
    Devices = 11,
    #[doc = "< profile id (Int)"]
    Profile = 12,
    #[doc = "< If route should be saved (Bool)"]
    Save = 13,
}
#[repr(u32)]
#[doc = " properties of SPA_TYPE_OBJECT_PropInfo"]
#[derive(
    Debug, Copy, Clone, Hash, PartialEq, Eq, num_derive :: FromPrimitive, num_derive :: ToPrimitive,
)]
pub enum SpaPropInfo {
    #[doc = "< associated id of the property"]
    Id = 1,
    #[doc = "< name of the property"]
    Name = 2,
    #[doc = "< type and range/enums of property"]
    Type = 3,
    #[doc = "< labels of property if any, this is a\n  struct with pairs of values, the first one\n  is of the type of the property, the second\n  one is a string with a user readable label\n  for the value."]
    Labels = 4,
    #[doc = "< type of container if any (Id)"]
    Container = 5,
    #[doc = "< is part of params property (Bool)"]
    Params = 6,
    #[doc = "< User readable description"]
    Description = 7,
}
#[repr(u32)]
#[doc = " predefined properties for SPA_TYPE_OBJECT_Props"]
#[derive(
    Debug, Copy, Clone, Hash, PartialEq, Eq, num_derive :: FromPrimitive, num_derive :: ToPrimitive,
)]
pub enum SpaProp {
    #[doc = "< an unknown property"]
    Unknown = 1,
    Device = 257,
    DeviceName = 258,
    DeviceFd = 259,
    Card = 260,
    CardName = 261,
    MinLatency = 262,
    MaxLatency = 263,
    Periods = 264,
    PeriodSize = 265,
    PeriodEvent = 266,
    Live = 267,
    Rate = 268,
    Quality = 269,
    BluetoothAudioCodec = 270,
    BluetoothOffloadActive = 271,
    WaveType = 65537,
    Frequency = 65538,
    #[doc = "< a volume (Float), 0.0 silence, 1.0 no attenutation"]
    Volume = 65539,
    #[doc = "< mute (Bool)"]
    Mute = 65540,
    PatternType = 65541,
    DitherType = 65542,
    Truncate = 65543,
    #[doc = "< a volume array, one (linear) volume per channel\n (Array of Float). 0.0 is silence, 1.0 is\n  without attenuation. This is the effective\n  volume that is applied. It can result\n  in a hardware volume and software volume\n  (see softVolumes)"]
    ChannelVolumes = 65544,
    #[doc = "< a volume base (Float)"]
    VolumeBase = 65545,
    #[doc = "< a volume step (Float)"]
    VolumeStep = 65546,
    #[doc = "< a channelmap array\n (Array (Id enum spa_audio_channel))"]
    ChannelMap = 65547,
    #[doc = "< mute (Bool)"]
    MonitorMute = 65548,
    #[doc = "< a volume array, one (linear) volume per\n  channel (Array of Float)"]
    MonitorVolumes = 65549,
    #[doc = "< delay adjustment"]
    LatencyOffsetNsec = 65550,
    #[doc = "< mute (Bool) applied in software"]
    SoftMute = 65551,
    #[doc = "< a volume array, one (linear) volume per channel\n (Array of Float). 0.0 is silence, 1.0 is without\n attenuation. This is the volume applied in\n software, there might be a part applied in\n hardware."]
    SoftVolumes = 65552,
    #[doc = "< enabled IEC958 (S/PDIF) codecs,\n  (Array (Id enum spa_audio_iec958_codec)"]
    Iec958Codecs = 65553,
    #[doc = "< Samples to ramp the volume over"]
    VolumeRampSamples = 65554,
    #[doc = "< Step or incremental Samples to ramp\n  the volume over"]
    VolumeRampStepSamples = 65555,
    #[doc = "< Time in millisec to ramp the volume over"]
    VolumeRampTime = 65556,
    #[doc = "< Step or incremental Time in nano seconds\n  to ramp the"]
    VolumeRampStepTime = 65557,
    #[doc = "< the scale or graph to used to ramp the\n  volume"]
    VolumeRampScale = 65558,
    Brightness = 131073,
    Contrast = 131074,
    Saturation = 131075,
    Hue = 131076,
    Gamma = 131077,
    Exposure = 131078,
    Gain = 131079,
    Sharpness = 131080,
    #[doc = "< simple control params\n    (Struct(\n\t  (String : key,\n\t   Pod    : value)*))"]
    Params = 524289,
}
#[repr(u32)]
#[doc = " media type for SPA_TYPE_OBJECT_Format"]
#[derive(
    Debug, Copy, Clone, Hash, PartialEq, Eq, num_derive :: FromPrimitive, num_derive :: ToPrimitive,
)]
pub enum SpaMediaType {
    Unknown = 0,
    Audio = 1,
    Video = 2,
    Image = 3,
    Binary = 4,
    Stream = 5,
    Application = 6,
}
#[repr(u32)]
#[doc = " media subtype for SPA_TYPE_OBJECT_Format"]
#[derive(
    Debug, Copy, Clone, Hash, PartialEq, Eq, num_derive :: FromPrimitive, num_derive :: ToPrimitive,
)]
pub enum SpaMediaSubtype {
    Unknown = 0,
    Raw = 1,
    Dsp = 2,
    Iec958 = 3,
    #[doc = " S/PDIF"]
    Dsd = 4,
    #[doc = " S/PDIF"]
    StartAudio = 65536,
    #[doc = " S/PDIF"]
    Mp3 = 65537,
    #[doc = " S/PDIF"]
    Aac = 65538,
    #[doc = " S/PDIF"]
    Vorbis = 65539,
    #[doc = " S/PDIF"]
    Wma = 65540,
    #[doc = " S/PDIF"]
    Ra = 65541,
    #[doc = " S/PDIF"]
    Sbc = 65542,
    #[doc = " S/PDIF"]
    Adpcm = 65543,
    #[doc = " S/PDIF"]
    G723 = 65544,
    #[doc = " S/PDIF"]
    G726 = 65545,
    #[doc = " S/PDIF"]
    G729 = 65546,
    #[doc = " S/PDIF"]
    Amr = 65547,
    #[doc = " S/PDIF"]
    Gsm = 65548,
    #[doc = " S/PDIF"]
    Alac = 65549,
    #[doc = " since 0.3.65"]
    Flac = 65550,
    #[doc = " since 0.3.65"]
    Ape = 65551,
    #[doc = " since 0.3.65"]
    Opus = 65552,
    #[doc = " since 0.3.68"]
    StartVideo = 131072,
    #[doc = " since 0.3.68"]
    H264 = 131073,
    #[doc = " since 0.3.68"]
    Mjpg = 131074,
    #[doc = " since 0.3.68"]
    Dv = 131075,
    #[doc = " since 0.3.68"]
    Mpegts = 131076,
    #[doc = " since 0.3.68"]
    H263 = 131077,
    #[doc = " since 0.3.68"]
    Mpeg1 = 131078,
    #[doc = " since 0.3.68"]
    Mpeg2 = 131079,
    #[doc = " since 0.3.68"]
    Mpeg4 = 131080,
    #[doc = " since 0.3.68"]
    Xvid = 131081,
    #[doc = " since 0.3.68"]
    Vc1 = 131082,
    #[doc = " since 0.3.68"]
    Vp8 = 131083,
    #[doc = " since 0.3.68"]
    Vp9 = 131084,
    #[doc = " since 0.3.68"]
    Bayer = 131085,
    #[doc = " since 0.3.68"]
    StartImage = 196608,
    #[doc = " since 0.3.68"]
    Jpeg = 196609,
    #[doc = " since 0.3.68"]
    StartBinary = 262144,
    #[doc = " since 0.3.68"]
    StartStream = 327680,
    #[doc = " since 0.3.68"]
    Midi = 327681,
    #[doc = " since 0.3.68"]
    StartApplication = 393216,
    #[doc = "< control stream, data contains\n  spa_pod_sequence with control info."]
    Control = 393217,
}
#[repr(u32)]
#[doc = " properties for audio SPA_TYPE_OBJECT_Format"]
#[derive(
    Debug, Copy, Clone, Hash, PartialEq, Eq, num_derive :: FromPrimitive, num_derive :: ToPrimitive,
)]
pub enum SpaFormat {
    Start = 0,
    #[doc = "< media type (Id enum spa_media_type)"]
    MediaType = 1,
    #[doc = "< media subtype (Id enum spa_media_subtype)"]
    MediaSubtype = 2,
    StartAudio = 65536,
    #[doc = "< audio format, (Id enum spa_audio_format)"]
    AudioFormat = 65537,
    #[doc = "< optional flags (Int)"]
    AudioFlags = 65538,
    #[doc = "< sample rate (Int)"]
    AudioRate = 65539,
    #[doc = "< number of audio channels (Int)"]
    AudioChannels = 65540,
    #[doc = "< channel positions (Id enum spa_audio_position)"]
    AudioPosition = 65541,
    #[doc = "< codec used (IEC958) (Id enum spa_audio_iec958_codec)"]
    AudioIec958Codec = 65542,
    #[doc = "< bit order (Id enum spa_param_bitorder)"]
    AudioBitorder = 65543,
    #[doc = "< Interleave bytes (Int)"]
    AudioInterleave = 65544,
    #[doc = "< bit rate (Int)"]
    AudioBitrate = 65545,
    #[doc = "< audio data block alignment (Int)"]
    AudioBlockAlign = 65546,
    #[doc = "< AAC stream format, (Id enum spa_audio_aac_stream_format)"]
    AudioAacStreamFormat = 65547,
    #[doc = "< WMA profile (Id enum spa_audio_wma_profile)"]
    AudioWmaProfile = 65548,
    #[doc = "< AMR band mode (Id enum spa_audio_amr_band_mode)"]
    AudioAmrBandMode = 65549,
    StartVideo = 131072,
    #[doc = "< video format (Id enum spa_video_format)"]
    VideoFormat = 131073,
    #[doc = "< format modifier (Long)\n use only with DMA-BUF and omit for other buffer types"]
    VideoModifier = 131074,
    #[doc = "< size (Rectangle)"]
    VideoSize = 131075,
    #[doc = "< frame rate (Fraction)"]
    VideoFramerate = 131076,
    #[doc = "< maximum frame rate (Fraction)"]
    VideoMaxFramerate = 131077,
    #[doc = "< number of views (Int)"]
    VideoViews = 131078,
    #[doc = "< (Id enum spa_video_interlace_mode)"]
    VideoInterlaceMode = 131079,
    #[doc = "< (Rectangle)"]
    VideoPixelAspectRatio = 131080,
    #[doc = "< (Id enum spa_video_multiview_mode)"]
    VideoMultiviewMode = 131081,
    #[doc = "< (Id enum spa_video_multiview_flags)"]
    VideoMultiviewFlags = 131082,
    #[doc = "< /Id enum spa_video_chroma_site)"]
    VideoChromaSite = 131083,
    #[doc = "< /Id enum spa_video_color_range)"]
    VideoColorRange = 131084,
    #[doc = "< /Id enum spa_video_color_matrix)"]
    VideoColorMatrix = 131085,
    #[doc = "< /Id enum spa_video_transfer_function)"]
    VideoTransferFunction = 131086,
    #[doc = "< /Id enum spa_video_color_primaries)"]
    VideoColorPrimaries = 131087,
    #[doc = "< (Int)"]
    VideoProfile = 131088,
    #[doc = "< (Int)"]
    VideoLevel = 131089,
    #[doc = "< (Id enum spa_h264_stream_format)"]
    VideoH264StreamFormat = 131090,
    #[doc = "< (Id enum spa_h264_alignment)"]
    VideoH264Alignment = 131091,
    StartImage = 196608,
    StartBinary = 262144,
    StartStream = 327680,
    StartApplication = 393216,
}
impl SpaAudioFormat {
    pub const DspS32: SpaAudioFormat = SpaAudioFormat::S2432P;
}
impl SpaAudioFormat {
    pub const DspF32: SpaAudioFormat = SpaAudioFormat::F32P;
}
impl SpaAudioFormat {
    pub const DspF64: SpaAudioFormat = SpaAudioFormat::F64P;
}
impl SpaAudioFormat {
    pub const S16: SpaAudioFormat = SpaAudioFormat::S16Le;
}
impl SpaAudioFormat {
    pub const U16: SpaAudioFormat = SpaAudioFormat::U16Le;
}
impl SpaAudioFormat {
    pub const S2432: SpaAudioFormat = SpaAudioFormat::S2432Le;
}
impl SpaAudioFormat {
    pub const U2432: SpaAudioFormat = SpaAudioFormat::U2432Le;
}
impl SpaAudioFormat {
    pub const S32: SpaAudioFormat = SpaAudioFormat::S32Le;
}
impl SpaAudioFormat {
    pub const U32: SpaAudioFormat = SpaAudioFormat::U32Le;
}
impl SpaAudioFormat {
    pub const S24: SpaAudioFormat = SpaAudioFormat::S24Le;
}
impl SpaAudioFormat {
    pub const U24: SpaAudioFormat = SpaAudioFormat::U24Le;
}
impl SpaAudioFormat {
    pub const S20: SpaAudioFormat = SpaAudioFormat::S20Le;
}
impl SpaAudioFormat {
    pub const U20: SpaAudioFormat = SpaAudioFormat::U20Le;
}
impl SpaAudioFormat {
    pub const S18: SpaAudioFormat = SpaAudioFormat::S18Le;
}
impl SpaAudioFormat {
    pub const U18: SpaAudioFormat = SpaAudioFormat::U18Le;
}
impl SpaAudioFormat {
    pub const F32: SpaAudioFormat = SpaAudioFormat::F32Le;
}
impl SpaAudioFormat {
    pub const F64: SpaAudioFormat = SpaAudioFormat::F64Le;
}
impl SpaAudioFormat {
    pub const S16Oe: SpaAudioFormat = SpaAudioFormat::S16Be;
}
impl SpaAudioFormat {
    pub const U16Oe: SpaAudioFormat = SpaAudioFormat::U16Be;
}
impl SpaAudioFormat {
    pub const S2432Oe: SpaAudioFormat = SpaAudioFormat::S2432Be;
}
impl SpaAudioFormat {
    pub const U2432Oe: SpaAudioFormat = SpaAudioFormat::U2432Be;
}
impl SpaAudioFormat {
    pub const S32Oe: SpaAudioFormat = SpaAudioFormat::S32Be;
}
impl SpaAudioFormat {
    pub const U32Oe: SpaAudioFormat = SpaAudioFormat::U32Be;
}
impl SpaAudioFormat {
    pub const S24Oe: SpaAudioFormat = SpaAudioFormat::S24Be;
}
impl SpaAudioFormat {
    pub const U24Oe: SpaAudioFormat = SpaAudioFormat::U24Be;
}
impl SpaAudioFormat {
    pub const S20Oe: SpaAudioFormat = SpaAudioFormat::S20Be;
}
impl SpaAudioFormat {
    pub const U20Oe: SpaAudioFormat = SpaAudioFormat::U20Be;
}
impl SpaAudioFormat {
    pub const S18Oe: SpaAudioFormat = SpaAudioFormat::S18Be;
}
impl SpaAudioFormat {
    pub const U18Oe: SpaAudioFormat = SpaAudioFormat::U18Be;
}
impl SpaAudioFormat {
    pub const F32Oe: SpaAudioFormat = SpaAudioFormat::F32Be;
}
impl SpaAudioFormat {
    pub const F64Oe: SpaAudioFormat = SpaAudioFormat::F64Be;
}
#[repr(u32)]
#[derive(
    Debug, Copy, Clone, Hash, PartialEq, Eq, num_derive :: FromPrimitive, num_derive :: ToPrimitive,
)]
pub enum SpaAudioFormat {
    Unknown = 0,
    Encoded = 1,
    StartInterleaved = 256,
    S8 = 257,
    U8 = 258,
    S16Le = 259,
    S16Be = 260,
    U16Le = 261,
    U16Be = 262,
    S2432Le = 263,
    S2432Be = 264,
    U2432Le = 265,
    U2432Be = 266,
    S32Le = 267,
    S32Be = 268,
    U32Le = 269,
    U32Be = 270,
    S24Le = 271,
    S24Be = 272,
    U24Le = 273,
    U24Be = 274,
    S20Le = 275,
    S20Be = 276,
    U20Le = 277,
    U20Be = 278,
    S18Le = 279,
    S18Be = 280,
    U18Le = 281,
    U18Be = 282,
    F32Le = 283,
    F32Be = 284,
    F64Le = 285,
    F64Be = 286,
    Ulaw = 287,
    Alaw = 288,
    StartPlanar = 512,
    U8P = 513,
    S16P = 514,
    S2432P = 515,
    S32P = 516,
    S24P = 517,
    F32P = 518,
    F64P = 519,
    S8P = 520,
    StartOther = 1024,
}
#[repr(u32)]
#[doc = " \\addtogroup spa_param\n \\{"]
#[derive(
    Debug, Copy, Clone, Hash, PartialEq, Eq, num_derive :: FromPrimitive, num_derive :: ToPrimitive,
)]
pub enum SpaAudioIec958Codec {
    Unknown = 0,
    Pcm = 1,
    Dts = 2,
    Ac3 = 3,
    #[doc = "< MPEG-1 or MPEG-2 (Part 3, not AAC)"]
    Mpeg = 4,
    #[doc = "< MPEG-2 AAC"]
    Mpeg2Aac = 5,
    Eac3 = 6,
    #[doc = "< Dolby TrueHD"]
    Truehd = 7,
    #[doc = "< DTS-HD Master Audio"]
    Dtshd = 8,
}
#[repr(u32)]
#[doc = " \\addtogroup spa_param\n \\{"]
#[derive(
    Debug, Copy, Clone, Hash, PartialEq, Eq, num_derive :: FromPrimitive, num_derive :: ToPrimitive,
)]
pub enum SpaBluetoothAudioCodec {
    Start = 0,
    Sbc = 1,
    SbcXq = 2,
    Mpeg = 3,
    Aac = 4,
    AacEld = 5,
    Aptx = 6,
    AptxHd = 7,
    Ldac = 8,
    AptxLl = 9,
    AptxLlDuplex = 10,
    Faststream = 11,
    FaststreamDuplex = 12,
    Lc3PlusHr = 13,
    Opus05 = 14,
    Opus0551 = 15,
    Opus0571 = 16,
    Opus05Duplex = 17,
    Opus05Pro = 18,
    OpusG = 19,
    Cvsd = 256,
    Msbc = 257,
    Lc3Swb = 258,
    Lc3 = 512,
}
impl SpaVideoFormat {
    pub const DspF32: SpaVideoFormat = SpaVideoFormat::RgbaF32;
}
#[repr(u32)]
#[doc = " Video formats\n\n The components are in general described in big-endian order. There are some\n exceptions (e.g. RGB15 and RGB16) which use the host endianness.\n\n Most of the formats are identical to their GStreamer equivalent. See the\n GStreamer video formats documentation for more details:\n\n https://gstreamer.freedesktop.org/documentation/additional/design/mediatype-video-raw.html#formats"]
#[derive(
    Debug, Copy, Clone, Hash, PartialEq, Eq, num_derive :: FromPrimitive, num_derive :: ToPrimitive,
)]
pub enum SpaVideoFormat {
    Unknown = 0,
    Encoded = 1,
    I420 = 2,
    Yv12 = 3,
    Yuy2 = 4,
    Uyvy = 5,
    Ayuv = 6,
    RgBx = 7,
    BgRx = 8,
    XRgb = 9,
    XBgr = 10,
    Rgba = 11,
    Bgra = 12,
    Argb = 13,
    Abgr = 14,
    Rgb = 15,
    Bgr = 16,
    Y41B = 17,
    Y42B = 18,
    Yvyu = 19,
    Y444 = 20,
    V210 = 21,
    V216 = 22,
    Nv12 = 23,
    Nv21 = 24,
    Gray8 = 25,
    Gray16Be = 26,
    Gray16Le = 27,
    V308 = 28,
    Rgb16 = 29,
    Bgr16 = 30,
    Rgb15 = 31,
    Bgr15 = 32,
    Uyvp = 33,
    A420 = 34,
    Rgb8P = 35,
    Yuv9 = 36,
    Yvu9 = 37,
    Iyu1 = 38,
    Argb64 = 39,
    Ayuv64 = 40,
    R210 = 41,
    I42010Be = 42,
    I42010Le = 43,
    I42210Be = 44,
    I42210Le = 45,
    Y44410Be = 46,
    Y44410Le = 47,
    Gbr = 48,
    Gbr10Be = 49,
    Gbr10Le = 50,
    Nv16 = 51,
    Nv24 = 52,
    Nv1264Z32 = 53,
    A42010Be = 54,
    A42010Le = 55,
    A42210Be = 56,
    A42210Le = 57,
    A44410Be = 58,
    A44410Le = 59,
    Nv61 = 60,
    P01010Be = 61,
    P01010Le = 62,
    Iyu2 = 63,
    Vyuy = 64,
    Gbra = 65,
    Gbra10Be = 66,
    Gbra10Le = 67,
    Gbr12Be = 68,
    Gbr12Le = 69,
    Gbra12Be = 70,
    Gbra12Le = 71,
    I42012Be = 72,
    I42012Le = 73,
    I42212Be = 74,
    I42212Le = 75,
    Y44412Be = 76,
    Y44412Le = 77,
    RgbaF16 = 78,
    RgbaF32 = 79,
    #[doc = "< 32-bit x:R:G:B 2:10:10:10 little endian"]
    XRgb210Le = 80,
    #[doc = "< 32-bit x:B:G:R 2:10:10:10 little endian"]
    XBgr210Le = 81,
    #[doc = "< 32-bit R:G:B:x 10:10:10:2 little endian"]
    RgBx102Le = 82,
    #[doc = "< 32-bit B:G:R:x 10:10:10:2 little endian"]
    BgRx102Le = 83,
    #[doc = "< 32-bit A:R:G:B 2:10:10:10 little endian"]
    Argb210Le = 84,
    #[doc = "< 32-bit A:B:G:R 2:10:10:10 little endian"]
    Abgr210Le = 85,
    #[doc = "< 32-bit R:G:B:A 10:10:10:2 little endian"]
    Rgba102Le = 86,
    #[doc = "< 32-bit B:G:R:A 10:10:10:2 little endian"]
    Bgra102Le = 87,
}
#[repr(u32)]
#[doc = " Properties for SPA_TYPE_OBJECT_ParamLatency\n\n The latency indicates:\n\n - for playback: time delay between start of a graph cycle, and the rendering of\n   the first sample of that cycle in audio output.\n\n - for capture: time delay between start of a graph cycle, and the first sample\n   of that cycle having occurred in audio input.\n\n For physical output/input, the latency is intended to correspond to the\n rendering/capture of physical audio, including hardware internal rendering delay.\n\n The latency values are adjusted by \\ref SPA_PROP_latencyOffsetNsec or\n SPA_PARAM_ProcessLatency, if present. (e.g. for ALSA this is used to adjust for\n the internal hardware latency)."]
#[derive(
    Debug, Copy, Clone, Hash, PartialEq, Eq, num_derive :: FromPrimitive, num_derive :: ToPrimitive,
)]
pub enum SpaParamLatency {
    Start = 0,
    #[doc = "< direction, input/output (Id enum spa_direction)"]
    Direction = 1,
    #[doc = "< min latency relative to quantum (Float)"]
    MinQuantum = 2,
    #[doc = "< max latency relative to quantum (Float)"]
    MaxQuantum = 3,
    #[doc = "< min latency (Int) relative to graph rate"]
    MinRate = 4,
    #[doc = "< max latency (Int) relative to graph rate"]
    MaxRate = 5,
    #[doc = "< min latency (Long) in nanoseconds"]
    MinNs = 6,
    #[doc = "< max latency (Long) in nanoseconds"]
    MaxNs = 7,
}
#[repr(u32)]
#[doc = " Properties for SPA_TYPE_OBJECT_ParamProcessLatency\n\n The processing latency indicates logical time delay between a sample in an input port,\n and a corresponding sample in an output port, relative to the graph time."]
#[derive(
    Debug, Copy, Clone, Hash, PartialEq, Eq, num_derive :: FromPrimitive, num_derive :: ToPrimitive,
)]
pub enum SpaParamProcessLatency {
    Start = 0,
    #[doc = "< latency relative to quantum (Float)"]
    Quantum = 1,
    #[doc = "< latency (Int) relative to graph rate"]
    Rate = 2,
    #[doc = "< latency (Long) in nanoseconds"]
    Ns = 3,
}
#[repr(u32)]
#[doc = " properties for SPA_TYPE_OBJECT_Profiler"]
#[derive(
    Debug, Copy, Clone, Hash, PartialEq, Eq, num_derive :: FromPrimitive, num_derive :: ToPrimitive,
)]
pub enum SpaProfiler {
    Start = 0,
    #[doc = "< driver related profiler properties"]
    StartDriver = 65536,
    #[doc = "< Generic info, counter and CPU load,\n (Struct(\n      Long : counter,\n      Float : cpu_load fast,\n      Float : cpu_load medium,\n      Float : cpu_load slow),\n      Int : xrun-count))"]
    Info = 65537,
    #[doc = "< clock information\n  (Struct(\n      Int : clock flags,\n      Int : clock id,\n      String: clock name,\n      Long : clock nsec,\n      Fraction : clock rate,\n      Long : clock position,\n      Long : clock duration,\n      Long : clock delay,\n      Double : clock rate_diff,\n      Long : clock next_nsec,\n      Int : transport_state))"]
    Clock = 65538,
    #[doc = "< generic driver info block\n  (Struct(\n      Int : driver_id,\n      String : name,\n      Long : driver prev_signal,\n      Long : driver signal,\n      Long : driver awake,\n      Long : driver finish,\n      Int : driver status,\n      Fraction : latency,\n      Int : xrun_count))"]
    DriverBlock = 65539,
    #[doc = "< follower related profiler properties"]
    StartFollower = 131072,
    #[doc = "< generic follower info block\n  (Struct(\n      Int : id,\n      String : name,\n      Long : prev_signal,\n      Long : signal,\n      Long : awake,\n      Long : finish,\n      Int : status,\n      Fraction : latency,\n      Int : xrun_count))"]
    FollowerBlock = 131073,
    StartCustom = 16777216,
}
#[repr(u32)]
#[doc = " properties for SPA_TYPE_OBJECT_ParamTag"]
#[derive(
    Debug, Copy, Clone, Hash, PartialEq, Eq, num_derive :: FromPrimitive, num_derive :: ToPrimitive,
)]
pub enum SpaParamTag {
    Start = 0,
    #[doc = "< direction, input/output (Id enum spa_direction)"]
    Direction = 1,
    #[doc = "< Struct(\n      Int: n_items\n      (String: key\n       String: value)*\n  )"]
    Info = 2,
}
#[repr(i32)]
#[doc = " \\enum pw_link_state The different link states"]
#[derive(
    Debug, Copy, Clone, Hash, PartialEq, Eq, num_derive :: FromPrimitive, num_derive :: ToPrimitive,
)]
pub enum PwLinkState {
    #[doc = "< the link is in error"]
    Error = -2,
    #[doc = "< the link is unlinked"]
    Unlinked = -1,
    #[doc = "< the link is initialized"]
    Init = 0,
    #[doc = "< the link is negotiating formats"]
    Negotiating = 1,
    #[doc = "< the link is allocating buffers"]
    Allocating = 2,
    #[doc = "< the link is paused"]
    Paused = 3,
    #[doc = "< the link is active"]
    Active = 4,
}
#[repr(i32)]
#[doc = " \\enum pw_node_state The different node states"]
#[derive(
    Debug, Copy, Clone, Hash, PartialEq, Eq, num_derive :: FromPrimitive, num_derive :: ToPrimitive,
)]
pub enum PwNodeState {
    #[doc = "< error state"]
    Error = -1,
    #[doc = "< the node is being created"]
    Creating = 0,
    #[doc = "< the node is suspended, the device might\n   be closed"]
    Suspended = 1,
    #[doc = "< the node is running but there is no active\n   port"]
    Idle = 2,
    #[doc = "< the node is running"]
    Running = 3,
}
