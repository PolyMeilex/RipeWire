use std::fmt::Write;

use libspa_consts::SpaType;
use quote::{format_ident, quote};

use crate::{camel_case, json, snake_case};

fn print_entry(entry: &json::Entry, out: &mut impl Write) {
    let ident = format_ident!(
        "{}",
        camel_case(crate::spa_short_name(&entry.name).unwrap())
    );

    let properties: Vec<_> = entry
        .properties
        .iter()
        .filter(|info| SpaType::from_raw(info.parent).unwrap() != SpaType::None)
        .filter_map(|info| {
            let ident = crate::spa_strip_parent_name(&entry.name, &info.name)?;
            let ident = if ident == "type" {
                format_ident!("ty")
            } else {
                format_ident!("{}", snake_case(ident))
            };
            Some((ident, info))
        })
        .collect();

    let obj_type = SpaType::from_raw(entry.r#type).unwrap();

    let props = properties.iter().map(|(ident, info)| {
        let name_doc = format!(" name: {}", info.name);
        let return_doc = format!(" returns: {:?}", SpaType::from_raw(info.parent).unwrap());

        let get = if let Some(key) = crate::get_key_enum(obj_type, info.r#type) {
            quote!(self.get(#key))
        } else {
            let ty = info.r#type;
            quote!(self.get_raw(#ty))
        };

        quote! {
            #[doc = #name_doc]
            #[doc = #return_doc]
            fn #ident(&self) -> Option<PodDeserializer> {
                #get
            }
        }
    });

    let doc = format!(" {}", entry.name);

    let get_raw = quote! {
        fn get_raw(&self, id: u32) -> Option<PodDeserializer> {
            self.0.clone().find(|v| v.key == id).map(|v| v.value)
        }
    };

    let get_typed = if let Some(key) = crate::get_key_enum_type(obj_type) {
        quote! {
            fn get(&self, key: #key) -> Option<PodDeserializer> {
                self.get_raw(key.to_u32().unwrap())
            }
        }
    } else {
        quote!()
    };

    let src = quote! {
        #[doc = #doc]
        #[derive(Debug)]
        pub struct #ident<'a>(pub PodObjectDeserializer<'a>);
        impl<'a> #ident<'a> {
            #get_raw
            #get_typed

            #(#props)*
        }
    };

    writeln!(out, "{src}").unwrap();
    writeln!(out).unwrap();
}

pub fn run() {
    let path = std::env::args().nth(1).expect("path to json");
    let src = std::fs::read_to_string(path).unwrap();
    let json: Vec<json::Entry> = serde_json::from_str(&src).unwrap();

    println!("// =============");
    println!("// This file is autogenerated by obj_gen");
    println!("// DO NOT EDIT");
    println!("// =============");
    println!();
    println!("use super::*;");
    println!();

    for e in json {
        let mut code_gen = String::new();
        print_entry(&e, &mut code_gen);
        let code_gen = prettyplease::unparse(&syn::parse_str::<syn::File>(&code_gen).unwrap());
        println!("{code_gen}");
        println!();
    }
}
